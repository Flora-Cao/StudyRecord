
## 4.1-4.25 cherno's video 学习记录

### Cherno's C++ video两节
1. auto用法（不能滥用，迭代器的类型可以用auto，类型名很长可以用auto）
2. C++如何工作（与Java等在虚拟机上编译运行的语言的区别，C++直接编译为机器能识别的二进制文件）

### Cherno's C++ video三节（11：00-11：30，18：30-19：00）
1. 对象生存期（栈作用域生存期）（定义在栈上的变量会随着作用域的结束，自动释放；但堆上的变量必须调用new和delete手动创建和释放，由此引出智能指针-可视为指针的封装）
2. 智能指针（unique_ptr/shared_ptr/weak ptr的用法）
    在生产程序中，尽可能地采用智能指针，可以提高可靠性、可维护性
    智能指针只是原始指针的包装，仍然存在一些限制

    需要头文件 include<memory>
    可以自动调用new和delete，帮助管理内存
    1. unique_ptr 该类型指针不能复制，只允许同一时间有一个智能指针unique ptr指向同一个内存空间。这是为了防止多个指针带来的释放矛盾。
    2. shared_ptr 共享指针
    实现方式取决于编译器和编译器使用的标准库。使用引用计数 = 可以跟踪你的指针有多少个引用。当引用计数为0时才会被删除。
    不是线程安全的
    3. weak ptr 弱指针
    weak ptr不会增加引用计数，但是可以访问对象.
    weak ptr可以被复制，但是同时不会增加额外的控制块来控制计数，仅仅声明这个指针还活着

3. 隐式转换和explicit关键字（构造函数可以根据传入参数隐式转换，但是每次只能隐式转换一次）
4. 虚函数（虚函数引入了dynamic dispatch-动态联编，通常通过虚函数表来实现编译，v表中包含基类中所有虚函数的映射，这样在运行时就可以将它们映射到正确的override-覆写函数）
5. 纯虚函数（C++中的接口interface）
- 可以将抽象基类作为参数（类型）放入一个通用的纯虚函数中，然后确保子类都实现了该纯虚函数，那么子类就可以调用该方法
- 一个成员函数或成员属性被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！

### 下午Cherno's video
1.继承的概述

### Cherno's video（0.5h）
1.类和结构体中的可见性（private、protected、public，利用可见性可以帮助编程者和使用者快速了解程序功能和访问权限）
2.const关键字（当常量引用类作为函数的传入参数，如print（const Entity& e）或者定义常量类const Entity& e时，调用的类内方法必须为常量函数，如int get（）const，否则无法调用）
3.mutable关键字（如果需要在类内常量函数中修改某个类内变量的值，可以在声明该变量时加上mutable关键字，mutable允许常量方法修改该变量；或者当lambda表达式进行值传递并需要改变传入的变量时，需要在lambda的[=]()后面加上mutable关键字，lambda表达式进行引用传递[&]()时不用加）
4.初始化列表（需要习惯的常用用法，可以使代码更清晰；更重要的功能在于：普通类型不会重复初始化，但是类类型可能在声明和初始化时均调用构造函数，存在性能上的浪费，而采用初始化列表不会重复构造，因此无论普通类型和类类型尽可能采用初始化列表是一个好习惯）


### cherno's video(1h)
1.栈与堆的区别：
- 栈是预先分配一段连续的内存，堆可以在程序运行过程中扩展大小（由空闲列表动态分配内存）
- 栈中数据在作用域结束后会由系统自动释放，但堆需要手动释放或者使用智能指针自动释放
- 栈从高地址内存开始存放数据，堆从低地址内存开始存放数据
- 栈的分配相当于一条CPU指令，而堆包括一系列操作，因此尽可能地在栈上存放数据，除非数据的生命周期比函数作用域更长、需要特别多的数据等情况需要在堆上存放数据
- CPU缓存线可以理解为CPU缓存中的最小缓存单位，栈中连续数据可以放到CPU缓存线上，减少cache miss；而堆很可能发生cache miss（但在小项目不区别不明显）

### 结合C++宝典.md文件＋cherno's video（1h）
C++中两种类型转换方式：
- C语言方式：    （int）char a；
- C++的cast转换：   static_cast/const_cast/dynamic_cast/reinterpret_cast
- 当转换对象是智能指针时，使用dynamic_point_cast来进行智能指针转换

1.C++的dynamic_cast
- 当我们做特定类型的类型转换时，这是一种安全机制，做了额外的工作来保证类型转换的有效
- 不是在编译时做类型转换，而是类似一个函数，在运行时计算（有运行产生的性能成本）
- 专门用于沿继承层次结构进行的强制类型转换，即用于基类型与派生类型之间的转换：
    - 只用于多态类类型，需要在基类中写虚函数（意味着基类是多态类型），于是基类拥有了一个虚函数表，派生类中重写虚函数并加入虚函数表
    - 派生类转换为基类，可以做隐式转换；而基类实例转换为派生类，需要dynamic_cast帮助验证是否有效转换，转换失败则会返回一个NULL指针（当然也可以强制转换，但存在安全隐患）
    - 例如：可以将 player类型实例 actualplayer 隐式转换成 基类entity类型，然后无需额外的代码，dynamic_cast就可以验证actualplayer可以成功转换成player类型，而无法转换成enemy类型——原因在于C++存储了运行时类型信息（runtime type information，RTTI），所以使用dynamic_cast时需要保证RTTI开启，同时也增加了一些开销

2.C++的预编译头文件（PCH）
- 学会在VS中的设置方法（将pch.h设置为预编译头文件，并在main.cpp中使用它）
- 预编译头文件中通常包含那些不再修改的标准模板库等，而不放入需要频繁修改的函数
- 项目首次编译时间较长，但在此之后修改main函数中的代码，使用PCH的项目编译速度明显比不使用预编译头文件要快，因为预编译头文件不会重复包含和编译
- 使用预编译头文件可以加速编译速度，使实际编写代码更加方便

### 上午cherno's video（dynamic_cast的用法）
cherno's video（15：00-17：00）
1. C++的类型转换（四种）——在一个新的项目中对参与者很友好
- static_cast：静态类型转换，编译时检查转换是否可能
- dynamic_cast：运行时检查
- reinterpret_cast：把类型双关表达出来，表示把这段内存解释称其他内容（没有做任何转换，只是把现有内存解释为另一种类型）
- const_cast：移除或添加变量的const修饰符的限定
C++包含多种类型转换的好处，一是可以在编译时进行检查（从而减少强制转换时意外犯的错误，如类型不兼容），二是可以在代码库中搜索存在类型转换的地方

2.C++的类型双关
- 一个基本类型的结构，没有指向内存中其他地方的指针，那么就可以重新解释整个结构或类
- 一种原始的、底层的访问
- 没有冗余地复制内存，选择另一种方式来解释那段内存，将原始类型作为指针，然后将其转换为另一种指针，如有必要还对其解引用
- 可以使用上述原始类型转换，也可以使用reinterpret_cast

### cherno's video
1. C++的联合体——通常用于实现类型双关，更加简洁
- 类似于类类型、结构体类型，但不同之处在于union只能占用一个成员的内存
- 如果联合体定义多个成员，这些成员指向同一内存（一个联合体只能有一个成员）
- 可以添加静态成员函数、普通函数、方法等，但是不能使用虚函数，还有一些其他的限制
- 通常匿名使用，但是匿名union不能含有成员函数

2. C++的虚析构函数
- 如果允许一个类拥有子类，那么将基类析构函数变为虚析构函数是必须的
- 虚析构函数，不意味着覆写析构函数，而是加上一个析构函数
- 使用虚析构函数，当我们把派生类当作多态类型处理（或者说当作基类类型处理），仍然会调用基类和派生类的析构函数
举例说明：
    - 基类A和派生类B，将派生类对象b引用为基类对象a，会调用基类和派生类的构造函数；
    - 但如果基类对象a被删除，只会调用基类的析构函数，而不去调用派生类b的析构函数
    - 这会造成内存泄漏，比如派生类中有开辟在堆上的成员变量，需要在派生类的析构函数中对该内存进行释放
            Base* base = new Derived();
            delete base;
3. C++的静态数组（std::array）
- STL中的vector类是在 堆上 创建底层数据存储
- STL中的array类 与 C语言数组，都是在 栈上 存放数据
    - array<int, 5> data; //可以使用data.size()方法
    - int data[5];
    区别在于：
        - array类有边界检查（在debug模式下），而数组没有
        - array是STL库中的类，可以使用迭代器、方法等

        - 函数形参中不确定数组大小：
        ```C++
        template<typename T>
        void printArray(const T& arrays){
            for (int i = 0; i < arrays.size(); i++)
            {
                std::cout << arrays[i] << std::endl;
            }
        }
        -----或者-----
        template<typename T, size_t size>
        void printArray(const std::array<T, size>& arr) {
            for (size_t i = 0; i < size; ++i)	{
                std::cout << arr[i] << std::endl;
            }
        }
        这个没限制array中的存储类型而且大小也获取到了。参数直接用const T& arr的话，没办法限制传进来的类型，后续对变量进行操作(例如arr.size())会报错，其他类型可能没有size方法
        int main() {  
            std::array<int, 5> datas;
            datas[0] = 0;
            print(datas);
        }
        ```